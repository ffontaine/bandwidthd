Programmed by David Hinkle, Commissioned by DerbyTech Routers of Illinois.  
Special thanks goes to Brice Beaman at brice@beamans.org for releasing the 
software and helping with debugging, Blaze at ts@spective.net for his 
excellent logo, and all the guys at havok for distributing clue.

You may use this software under any verson of the GPL that is current as of
your download.  For exact terms and conditions please see www.gnu.org.  

# WHAT IT IS #
Bandwidthd is a unix deamon for graphing the traffic generated by each machine
on several configurable subnets.  It is much easier to configure than mrtg, and
provides significanlty more usefull information.  You don't just know that your
T1 is toast, you know who's holding down the little slidy thing on the toaster.

Each ip address that has moved any significant volume of traffic has its own
graph.  The graphs are color coded to help you figure out at a glance if he's
surfing the web, or surfing Kazaa.

Bandwidthd is targeted to run on my routing platforms.  It is very low 
overhead.  Easily graphing a small buisnesses traffic on a 133Mhz Elan 486
every 2.5 minutes. My entire ISP (2000-3000 Ip addresses across 4 states) is 
graphed on a celeron 450 every 10 minutes. Load average is 0.00 0.00 0.00.  

# PORTABILITY #
Bandwidthd has been made to successfully run on a large number of 
architectures.  However, I don't have access here to anything other than 
linux.  If you would like to provide support for another architecture, 
simply preform the neccisary modifications and post me a patch on sourceforge.
I'll see that it gets in.

# INSTALATION INSTRUCTIONS #

Get and install libpcap from http://www.tcpdump.org/
Get and install libpng from http://www.libpng.org/
Get and install libgd from http://www.boutell.com/gd/
Make sure your system supports System V IPC

make install

edit /usr/local/bandwidthd/etc/bandwidthd.conf

It's a list of the subnets to collect info on, and the device to listen
on.

Bandwidthd will install under /usr/local/bandwidthd.  It will create a
htdocs directory.  When you run bandwidthd, it creates its web tree in
htdocs in the current directory, so cd to /usr/local/bandwidthd and run it
with "./bandwidthd".  If you run it with "/usr/local/bandwidthd" it will not
work.

# GRAPHING INTERVAL #
Bandwidthd defaults to graph up to 3000 local ip's every 2.5 minutes.  If you 
need to track more ip's, change IP_NUM in bandwidthd.h.  More ip addresses 
require more system V shared memory. 3000 ip addresses uses 216k.

If your machine just doesn't have the power to graph all those ip addresses
every 2.5 minutes, increase the graphing interval.

To change the graphing interval modify the "skip_intervals" line in 
bandwidthd.conf in bandwidthd.h.  This is how many intervals to skip between 
graph runs.  "skip_interval" of 1 graphs every 5 minutes, 2 graphs every 7.5
minutes.

Also note that bandwidthd does not bother to graph an ip that has trasmited
less than 1Mbit of data.  It does however, include that ip in the table of ip's
at the top of the page, so it's traffic can still be viewed.  This cutoff can
be changed by modifying graph_cutoff in bandwidthd.conf.  "graph_cutoff" is in 
kilobytes.

Bandwidthd can be made to log to CDF by setting "output_cdf" to true.
(As of V1.1.4) This will now log out each intervals traffic, so you can import
them into a database and use a tool like access to create your own graphs,
or implement 95 percentile billing, for example.  Sending bandwidthd a HUP
will cause it to rotate it's logs.  It will rotate out 5 times before deleting
the oldest log file.  The fields in the cdf output file are in the same order
they are in on the web page.

Graphing can be disabled by setting "graph" to false. This will still log, and
still build the table of ip's, but the graph section will be omited.

# HOW TO KEEP YOUR GRAPHS BETWEEN REBOOTS #
In the bandwidthd.conf file set:
output_cdf true
recover_cdf true

output_cdf will cause bandwidthd to log all of it's data to the log.cdf file 
in it's directory.  recover_cdf will cause bandwidthd to load that file when 
it starts.   You will also want to make a crontab entry like so:

0 0 * * * * /bin/killall -HUP bandwidthd

This will send bandwidthd a HUP every night at midnight.  When bandwidthd 
recieves a HUP it rotates it's log files.  Bandwidthd will also recover data
from the rotated log files when it starts.  It will rotate each log file out
5 times, then delete it.  Bandwidthd creates pretty big logs if it's tracking
alot of ip addresses, so you will want to do this.

# COLOR CODES #
RED 	ICMP
BROWN	UDP
YELLOW	IP ENCAPSULATED (Ip over Ip, IPSEC, most VPN's)
BLUE 	HTTP (Port 80 TCP, actually)
PURPLE	Peer2Peer (Lots of TCP ports generally used by P2P software)
GREEN	TCP

# KNOWN BUGS AND TROUBLESHOOTING #

Bandwidthd doesn't do a very good job of tracking ftp.  This is because only
some ftp server software follows the rfc standard of sourceing all ftp 
transfers from port 20.  Surprisingly, Microsofts ftp deamon is compliant in
this regard, whereas most open source deamons are not.

If you try to compile bandwidthd with sun make, you'll get this error:
make: Fatal error in reader: Makefile, line 13: Unexpected end of line seen
Compile with gnu make, or overwrite Makefile with Makefile.solaris.

Some versions of make shipping with OpenBsd complain about missing dependancy 
operators.  Use gnu make if you can, if you can't, figure out how to fix the 
make file and supply me with a Makefile.OpenBsd.

Sometimes bandwidthd won't make, canning out with an error like:
bandwidthd.c:251: Structure has no member named `source'
bandwidthd.c:252: Stucture has no member names `dest'

This is because there are two versions of the tcphdr structure.  Some unixes
use `source' and `dest', others use `th_sport' and `th_dport'.  If you get the
error, change the "#ifdef SOLARIS" line to "#ifdef TRUE".  If someone can shed
some light on this situation for me, that would be great.

If bandwidthd is running on a machine without enough power to graph all the ip
addresses it is monitoring it can get itself (and your box) into a bad place.
I monitor small subnets on 133Mhz 486's, and my entire ISP (2000-3000 IP's) on 
a Celeron 450 (loadavg is 0.00 across the board even with bandwidthd running.)  
If your machine can't keep up with these beasts, or you try and graph your 
international backbone on that 386 in the closet, bandwidthd will end up 
accidently forking a second graphing process while the first one is still 
running.  This increases the load, and pretty much assures the second one 
will not finish before the third one begins.  The situation will feed on itself 
until your box has 0 cpu left.  I nice(4) after forking to try and reduce the 
repercutions of this problem.  If you have this problem just increase the 
interval between graphing runs.  See above.  

Bandwidthd always runs out of the current directory, it doesn't go looking in 
/usr/local/bandwidthd for it's stuff.  Always cd to /usr/local/bandwidthd (or,
for that matter, wherever you want to put it) before you run it.

Bandwidthd forks to perform it's graphing functions.  After this fork finishes 
it remains as a zombie until the next interval, at which time it is reaped by 
the main process.  This zombie is nothing to worry about, it's just an entry 
in the process table waiting to be deleted.

By default, bandwidthd now runs in promiscuous mode.  This means it can be used
to monitor traffic not routing through it's host.  Just make sure that the host
and the actual router are on the same hub (Not switch) and everything will be 
ok. Under some circumstances, traffic may get counted twice.  If traffic routes
to the other router, then routes back out along the same wire, it may get counted 
twice by bandwidthd.  This is much less of a problem than you might think, due
to a little known packet called an "icmp redirect" that causes all packets after
the first to go directly to it's target.  If you find that traffic looks like it's 
getting counted twice, make sure you're not firewalling off the icmp redirects.  
If you find that you actually see none of this traffic, it may be because the icmp
redirects cause it to ultimatly end up going from one port on a switch to another, 
never touching your hub. If you want bandwidthd to only see traffic actually going 
into and out of the host set "promiscuous" to false in bandwidthd.conf.

Bandwidthd supports ethernet and linux cooked socket packet encapsulation.  If 
you get an "Unknown Datalink Type" error, bandwidthd has not been programed to 
handle the physical encapsulation of the ip packets on that interface.  If 
you send me a sample capture and a copy past of the error message I'll see if
I can't make bandwidthd work for you.